{% comment %} <script defer>
function swymCallbackFn(swat) {
  const DEBOUNCE_MS = 400;
  const COUNTER_SELECTOR = ".swym-wishlist-header-counter";
  let updateTimeout;

  const $counters = () => document.querySelectorAll(COUNTER_SELECTOR);

  const getItemKey = i =>
    i?.epi ?? i?.pid ?? i?.id ?? (i?.du || i?.iu || JSON.stringify(i)).slice(0, 200);

  const showCounters = () =>
    $counters().forEach(el => {
      el.style.visibility = "visible";
      el.classList.add("swym-counter-ready");
    });

  const renderCount = count =>
    requestAnimationFrame(() =>
      $counters().forEach(el => {
        el.textContent = count;
        el.classList.add("swym-counter-ready");
        el.style.visibility = "visible";
        el.classList.add("show-badge");
      })
    );

  const computeCount = (lists, multi) => {
    if (!Array.isArray(lists) || !lists.length) return 0;
    if (multi) return lists.reduce((a, l) => a + (l.listcontents?.length || 0), 0);

    const seen = new Set();
    lists.forEach(l =>
      l.listcontents?.forEach(i => {
        const key = getItemKey(i);
        if (key && !seen.has(key)) seen.add(key);
      })
    );
    return seen.size;
  };

  const updateWishlistCount = () => {
    clearTimeout(updateTimeout);
    updateTimeout = setTimeout(() => {
      const multi =
        typeof SwymEnabledCommonFeatures !== "undefined" &&
        SwymEnabledCommonFeatures["multiple-wishlist"];

      swat.fetchLists({
        callbackFn: lists => {
          try {
            renderCount(computeCount(lists, multi));
          } catch (e) {
            console.error("Error computing wishlist total:", e);
            showCounters();
          }
        },
        errorFn: e => {
          console.error("Error fetching lists:", e);
          showCounters();
        }
      });
    }, DEBOUNCE_MS);
  };

  // Initial render
  updateWishlistCount();

  // Listen to Swym events
  ["sw:addedtowishlist", "sw:removedfromwishlist"].forEach(evt =>
    swat.evtLayer.addEventListener(evt, updateWishlistCount)
  );

  // --- Robust MutationObserver for dynamic cart/header updates ---
  const observeHeader = () => {
    const headerActions = document.querySelector("header-actions");
    if (!headerActions) return;

    const observer = new MutationObserver(mutations => {
      let shouldUpdate = false;

      mutations.forEach(mutation => {
        if (mutation.type === "childList") {
          mutation.addedNodes.forEach(node => {
            if (
              node.nodeType === 1 && 
              (node.matches(COUNTER_SELECTOR) || node.querySelector(COUNTER_SELECTOR))
            ) {
              shouldUpdate = true;
            }
          });
        }
      });

      if (shouldUpdate) {
        // Small delay to allow cart module to finish its render
        setTimeout(updateWishlistCount, 100);
      }
    });

    observer.observe(headerActions, { childList: true, subtree: true });
  };

  // Retry until header-actions exists (for modules loading asynchronously)
  const waitForHeader = () => {
    if (document.querySelector("header-actions")) {
      observeHeader();
    } else {
      setTimeout(waitForHeader, 200);
    }
  };

  waitForHeader();
}

window.SwymCallbacks = window.SwymCallbacks || [];
window.SwymCallbacks.push(swymCallbackFn);
</script> {% endcomment %}
